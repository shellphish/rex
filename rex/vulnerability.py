import logging

import angr
from angr.sim_type import SimTypeString

l = logging.getLogger("rex.Vulnerability")

class Vulnerability(object):

    IP_OVERWRITE              = "ip_overwrite"
    PARTIAL_IP_OVERWRITE      = "partial_ip_overwrite"
    UNCONTROLLED_IP_OVERWRITE = "uncontrolled_ip_overwrite"
    BP_OVERWRITE              = "bp_overwrite"
    PARTIAL_BP_OVERWRITE      = "partial_bp_overwrite"
    WRITE_WHAT_WHERE          = "write_what_where"
    WRITE_X_WHERE             = "write_x_where"
    UNCONTROLLED_WRITE        = "uncontrolled_write" # a write where the destination address is uncontrolled
    ARBITRARY_READ            = "arbitrary_read"
    NULL_DEREFERENCE          = "null_dereference"
    ARBITRARY_TRANSMIT        = "arbitrary_transmit" # transmit where the buf argument is completely controlled
    ARBITRARY_RECEIVE         = "arbitrary_receive" # receive where the buf argument is completel controlled
    FORMAT_STRING_BUG         = "format_string_bug"

Exploitables = [Vulnerability.IP_OVERWRITE, Vulnerability.PARTIAL_IP_OVERWRITE, Vulnerability.BP_OVERWRITE,
                Vulnerability.PARTIAL_BP_OVERWRITE, Vulnerability.WRITE_WHAT_WHERE, Vulnerability.WRITE_X_WHERE,
                Vulnerability.FORMAT_STRING_BUG]
# TODO: add arbitrary receive into this list
#       add format string bug into this list
Explorables = [Vulnerability.ARBITRARY_READ, Vulnerability.WRITE_WHAT_WHERE, Vulnerability.WRITE_X_WHERE]
Leakables = [Vulnerability.ARBITRARY_READ, Vulnerability.ARBITRARY_TRANSMIT]



# TODO: using an exhaustive list to detect format string bug is not a good idea.
# But it is a feasible way at the moment. Maybe later we can use some function
# signature analysis to detect it dynamically.
# the config is {func_name, position of the format}
# TODO: there are other format string functions. for example: syslog stuff.
FORMAT_FUNC1 = ["printf", "vprintf", "scanf", "vscanf"]
FORMAT_FUNC2 = ["fprintf", "dprintf", "sprintf", "vfprintf", "vdprintf", "vsprintf",
                "fscanf", "sscanf", "vfscanf", "fsscanf"]
FORMAT_FUNC3 = ["snprintf", "vsnprintf"]
FORMAT_FUNCS = [FORMAT_FUNC1, FORMAT_FUNC2, FORMAT_FUNC3]

def check_fsb(state):
    if not state.project.is_hooked(state.addr):
        return False
    sim_func = state.project.hooked_by(state.addr)

    # check whether it is a format string function
    # is yes, which argument is the format
    for i in range(len(FORMAT_FUNCS)):
        FORMAT_FUNC = FORMAT_FUNCS[i]
        if sim_func.display_name in FORMAT_FUNC:
            pos = i
            break
    else:
        return False

    # perfrom calling convention analysis and extract the format argument

    # TODO: currently, the CFGFast will fail when auto_load_libs is True,
    # to circumvent that, we create a new project each time, which is
    # extremely slow
    proj = angr.Project(state.project.filename, auto_load_libs=False)
    proj.analyses.CFG() # fill in knowledge base
    proj.analyses.CompleteCallingConventions(recover_variables=True)
    func = proj.kb.functions[sim_func.display_name]

    # extract arguments across projects. I think it should be fine
    args = func.calling_convention.get_args(state)

    # now check if is a symbolic string
    fmt = args[pos]
    sim_str = SimTypeString()
    try:
        sim_str.extract(state, fmt)
    except ValueError:
        return True
    return False
