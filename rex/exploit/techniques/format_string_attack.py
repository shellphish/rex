import logging

import angr
from angrop.errors import RopException

from ...vulnerability import Vulnerability, FORMAT_FUNCS
from .. import Exploit, CannotExploit
from ..technique import Technique

l = logging.getLogger("rex.exploit.techniques.rop_to_execl")
MAX_OFFSET = 0x1000

class FormatStringAttack(Technique):

    name = "format_string_attack"
    applicable_to = ['unix']

    def check(self):
        return Vulnerability.FORMAT_STRING_BUG in self.crash.crash_types

    def _get_fmt_pos(self):
        """
        Get the format position in the format string function.
        For example, format position in `printf` is 1.
        format position in `sprintf` is 2.
        """
        for i in range(len(FORMAT_FUNCS)):
            FORMAT_FUNC = FORMAT_FUNCS[i]
            if self.func.name in FORMAT_FUNC:
                return i+1
        else:
            raise ValueError("%s is not a format string function!!" % self.func.display_name)

    def _extract_info(self):
        """
        extracted info:
        arg_offset: the first argument number under our control
        bytes_printed: how many bytes printed before our controlled format
        """
        # TODO: right now, it is assumed that bytes_printed is 0
        # And the format is fully controlled by the user
        arg_offset = 0
        bytes_printed = 0
        state = self.crash.state
        cc = self.func.calling_convention
        arch_bytes = state.project.arch.bytes
        fmt_pos = self._get_fmt_pos()

        fmt_ptr = self.func.calling_convention.get_args(state)[fmt_pos-1]
        arg_start = state.regs.sp + cc.STACKARG_SP_DIFF + fmt_pos * arch_bytes

        # notify user if it is not supported
        if not state.solver.symbolic(state.memory.load(fmt_ptr, 1)):
            raise NotImplementedError("format string with bytes printed is not supported yet!")

        arg_offset = (fmt_ptr - arg_start) / arch_bytes + 1
        arg_offset = state.solver.eval(arg_offset)
        return arg_offset, bytes_printed

    def _analyze_vuln_func(self):
        state = self.crash.state
        sim_func = state.project.hooked_by(state.addr)

        # TODO: currently, the CFGFast will fail when auto_load_libs is True,
        # to circumvent that, we create a new project each time, which is
        # extremely slow
        proj = angr.Project(state.project.filename, auto_load_libs=False)
        proj.analyses.CFG() # fill in knowledge base
        proj.analyses.CompleteCallingConventions(recover_variables=True)
        func = proj.kb.functions[sim_func.display_name]
        self.func = func

    def apply(self, **kwargs):
        self.func = None
        self._analyze_vuln_func()
        arg_offset, bytes_printed = self._extract_info()

        # first of all ide
        return Exploit(self.crash, bypasses_nx=True, bypasses_aslr=True)
